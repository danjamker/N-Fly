<text id="J69" category="" words="2021" checkedby="" modifiedby="" Title="MetaOCaml server pages: Web publishing as staged computation" Author="Christopher League" PublicationDate="2006" SampledFrom="Science of Computer Programming 62 (2006) 66 - 84" WebAddress="http://www.sciencedirect.com/science?_ob=MImg&_imagekey=B6V17-4K7WHY9-2-1&_cdi=5667&_user=196517&_pii=S0167642306000748&_origin=browse&_zone=rslt_list_item&_coverDate=09%2F30%2F2006&_sk=999379998&wchp=dGLzVzb-zSkzS&md5=a1dc660e5c373ce2b7f64c780a5a9fc1&ie=">

Modern dynamic web sites support many features for user collaboration and personalization. To provide such services, web sites contain custom computer programs, often written in one of a family of programming languages that have grown up around (or been adapted for) the web.
There is at least one dictum of program design that we cannot escape on the web: performance matters. As a web publisher, visitors are your livelihood. But will your servers and scripts be ready for the day that your site is featured on prime time television, or on slashdot.org? If tens of thousands of potential users drop by to find a sluggish (or dead) server, most of them will never return.
This happens so often to sites featured on Slashdot - a "news for nerds" discussion site - that it has come to be known as the Slashdot effect: "a site that might be designed to handle a few hundred hits per day can suddenly find itself handling that many a second". Although some ISPs have bandwidth limitations, Slashdot creator RobMalda says most sites that fail suffer from poor planning and architecture:
Anybody who has a pretty good understanding of web design [has] done a good job of learning what information to cache [and] what needs to be pre-generated. So when you're actually loading a page, even if it's a complicated page that looks dynamic and custom, on the back end of that, what they're really doing is putting together a bunch of puzzle pieces that have been pre-generated, and making the simplest, quickest decisions they possibly can.
Malda's observation points (informally) to the idea of staging the computation performed by a web service. Indeed, web publishing is an application area that is naturally staged1:
(1) Content (text, images, programs, etc.) created off-line is uploaded to the server - the publish stage;
(2) A user's browser requests content, which is transferred from server to client - the serve stage; and finally
(3) The content is rendered within the user's browser - the display stage.2
At each stage there is an opportunity for computation to take place.3 Consider the example of a conference calendar, such as the one illustrated in Fig. 1. After specifying your areas of interest (perhaps using the ACM classifications),
the server delivers a table of matching conferences, with dates, locations, deadlines, and links to conference websites. Events remain in the table until a few weeks after they occur, but deadlines that have passed are marked in red.
You may click on any column header to change the sort order. The next time you visit, the server remembers your preferences. Perhaps it even sends you email to remind you of upcoming submission and registration deadlines.
Now, how might this conference service be staged? Can anything be computed off-line (at the publish stage)? Yes: since this page is probably part of a much larger site (whose structure does not change every day), the menus and other
navigation aids can be laid out in advance.We will not know which conferences to display until the user presents some identification (in the form of a "cookie"), but since the conference data change infrequently, it may help to prepare the text of each row in advance.
During the serve stage, we look up the user's topic preferences, and ship out just the matching rows. If we delay sorting the table until the display stage, then the user ought to be able to adjust the sort criteria without any further communication with the server. What about marking past dates in red? If this is also delayed until display, then the code could be cached client-side for long periods of time, yet still behave dynamically.
At this point, we should emphasize the importance of profiling in developing scalable web services. This particular design for the conference calendar may not be optimal, depending on the number of entries and the relative speeds of the CPU, memory, database, network, and disk. Rather, our aim is to provide a single language in which the various staging possibilities can be expressed naturally.
This approach is in stark contrast to the status quo, where each system targets one stage only. The Website Meta Language4 is an "off-line HTML generation toolkit" designed for the publish stage. But many other programs (and countless ad hoc scripts) spit out HTML pages: LATEX2HTML, for example. Google reports surprisingly many programs5 for creating family tree web sites from genealogy database files; these also count as publish-stage tools.
The serve stage is well-served by the "server page" languages, including JSP, ASP, and PHP. The Common Gateway Interface (CGI)6 addresses the serve stage, as do the embedded interpreters (such as mod perl and mod python for Apache) that exist to ameliorate some of the overhead of CGI.
There is, relatively, a paucity of languages that operate client-side (display stage), probably due to the difficulty of securing an installed base of interpreters. JavaScript, Java, and Flash applets are notable exceptions.
Imagine implementing the conference calendar, as conceived above, using currently deployed technology: a Perl script outputs a PHP page which embeds JavaScript! Values are passed from one stage to the next as strings, and the programmer must manage all the quoting and persistence issues by hand.
Strictly speaking, these languages are not exclusively confined to the stages that we have indicated: Javascript can be run server-side, PHP can be run off-line, and so on. Nevertheless, migrating code between stages is hard, and the need for quoting and persistence are practically show-stoppers. For comparison purposes (further described in Section 5), we staged some code using PHP. To achieve persistence of composite variables from one stage to the next,
it contains gems like this:
where the serialize library function occurs in stage one and the unserialize in stage two. Notice that the preceding the first occurrence of list is quoted, but the second occurrence is not. The addcslashes function is needed in case the serialized representation contains special characters (such as double quotes or newlines) that would be misinterpreted by the PHP parser in the next stage. Interpreting the stage-one program guarantees nothing about the well-formedness of the stage-two program (generated as a string).
We present "MetaOCaml server pages", a new domain-specific language for web applications programming. It leverages the staging annotations and static typing of MetaOCaml [1,19] to provide safe and precise control over the first two stages. (We leave further consideration of the display stage as future work.) The system is implemented as two components: a translator transforms the server page language into a MetaOCaml module, which then can be incorporated into our multi-threaded HTTP/1.1 server (also written in MetaOCaml). The scalability gained by staging certain applications is stunning: In Section 5 we describe a directory browsing service where staging yields a factor of 30 improvement in throughput. The unstaged version would certainly succumb to the Slashdot effect.
The next section sketches the design and translation of MetaOCaml server pages, and Section 3 includes some non-trivial examples. The server implementation is described in Section 4. Performance and scalability are discussed
in Section 5.
Design
The general idea of a server page language is that we write HTML by default, and embed code &lt;?like this.
PHP programmers are familiar with this syntax for embedding code, but in our case, the code itself is written in MetaOCaml. Here is a trivial MetaOCaml server page:
The OCaml function failwith raises a Failure exception containing the provided message. If a code block raises an exception, the message is sent to the client's browser in boldface, and the rest of the page is aborted.
In this example and throughout this paper, a sans-serif font is used for embedded MetaOCaml code, with bold sans reserved for keywords and code delimiters. A typewriter font is used for MetaOCaml character strings. The regular serif font is used for plain text and HTML within the server page, and for comments within the MetaOCaml code blocks.

A very common use of code blocks is to print out (i.e., send to the browser) the result of evaluating some expression.
The syntax  is designated for this task; e must have type string. Alternatively, messages may be formatted with sprintf by placing the format string immediately after the code delimiter.
The output is:
One more kind of code delimiter is used for declarations; these are lifted to the top of your program, and evaluated during the publishing stage:
Permissions on current directory are 
Output:
Permissions on current directory are Once published, this output will never change! The stat call is executed only once (because it is in a declaration block), not on each request. This is already a rudimentary kind of staging, but with the annotations of MetaOCaml, we will gain both flexibility and safety, as we'll see in the rest of this section.
Review of staging annotations
MetaOCaml augments OCaml with just three annotations, to indicate how programs are to be staged. Brackets construct future-stage computation. The code within is not executed in the current stage of computation, but just returned as a code value that can be run later.
Within brackets, the splice or escape operator  may appear. It interrupts the code construction to evaluate the expression e (in the current stage) and splice its result into the future-stage computation. Thus, e is required to evaluate to code of the proper type.
To compute and splice in a regular (non-code) value, we define a function let lift. this takes any value and turns it into code. We use it like this: The addition is performed immediately (because it is escaped), and the result is spliced into the code. Finally, there is an operator to execute constructed code. Applying it to the example above, produces 14.
Translation to MetaOCaml
To see how all this works, consider how a MetaOCaml server page is translated into a proper MetaOCaml program, to be executed at publish time. Since the program is executed before any browser has requested the page, it cannot directly return or output HTML. Instead, it will construct and return a code object which is subsequently run on each request (serve stage). The third (display) stage proposed in Section 1 is not yet supported by this design. Fig. 2 shows a sample MetaOCaml server page, and Fig. 3 contains its translation.
Declaration blocks have been lifted to the top; any side effects contained there are executed when the page is published. The constructed code begins on line 5.
The a b c represent publish-stage arguments (the names are specified with pragma args), whereas req and puts are (fixed) serve-stage arguments. req encapsulates the HTTP request details, including the headers and query arguments. puts is a function, provided by the server, to transmit text across the network to the user's browser. The library function Request.arg of the type request!string!string option looks up the string value of the request parameter with a given name. The option type constructor permits the function to return None if there is no matching parameter in the HTTP request. On line 6, arg is defined as a short-cut for retrieving a parameter by name. Since req and puts are serve-stage arguments, it is incorrect to use them in the publish (first) stage, and indeed the MetaOCaml type system prevents this.
These, along with the lift function defined near the top, are essentially primitives from the point of view of the server page code.
Staged code blocks
Now that we understand how the server page is assembled into a staged program, the effects of adding MetaOCaml staging operators to our pages should be predictable. Below is another example using stat, this time to display the size of some text file on the server. With the serve-stage argument unit, we can specify whether the size should be expressed in bytes (the default), kilobytes, etc.
If this text file does not change frequently (and reporting outdated information is no problem), the stat and float of int calls could be lifted into the declaration block, as with the permissions example. Furthermore, we may also use lift and the splice operator to perform the divisions in advance, even though they are underneath the match (which cannot happen until the serve stage):

</text>
